\section{Progettazione}
\subsection{Algoritmo per riconoscimento di elementi in un'immagine frammentata}
Per quanto riguarda il problema della frammentazione dei frames in 4K è stato individuato un apposito algoritmo in grado di effettuare il riconoscimento degli oggetti in nei frames presenti senza doverli ridimensionare ma utilizzando la tecnica della frammentazione dell'immagine.
\subsubsection{Scomposizione del frame originale in regioni}
Un frame in 4K viene scomposto in una matrice di n x m sotto-immagini chiamate regioni\gls in modo tale che ogni regione sia efficacemente analizzabile un modello come Faster R-CNN. Per facilitare l'operazione di riconoscimento degli elementi da parte della rete, ogni regione si sovrappone leggermente con le sue regioni adiacenti. Per definire la quantità di pixels da coinvolgere nella sovrapposizione viene definito uno stride\gls che indica quanti pixels della regione tralasciare, sia in verticale che in orizzontale, prima che cominci quella successiva, ovviamente lo stride deve essere minore della larghezza di una regione.
Una Faster R-CNN dopo aver elaborato singolarmente ogni regione come se fosse una singola immagine darà in output una lista di labels\gls con le seguenti caratteristiche:
\begin{itemize}
\item \textbf{(max-x, max-y)}: coordinate del vertice in alto a sinistra del rettangolo rappresentante la label dell'oggetto riconosciuto; 
\item \textbf{(min-x, min-y)}: coordinate del vertice in basso a destra del rettangolo rappresentante la label dell'oggetto riconosciuto; 
\item \textbf{Categoria\gls}: è un numero naturale che indica la categoria di appartenenza dell'elemento individuato;
\item \textbf{Score\gls}: rappresenta la misura di probabilità che la classificazione ottenuta sia effettivamente quella corretta.
\end{itemize}
Successivamente viene aggiustata la posizione delle labels individuate in modo da traslarle nella loro posizione corretta all'interno dell'immagine originale non frammentata. Questo viene fatto aggiungendo un adeguato offset alle coordinate dei vertici dei box delle labels sulla base della loro regione di appartenenza.
\subsubsection{Rimozione degli elementi individuati più volte all'interno delle aree di sovrapposizione}
A causa della presenza delle aree di sovrapposizione dovute alla struttura delle regioni, gli elementi giacenti in queste particolari zone del frame verranno individuati tante volte quante sono le regioni che si sovrappongono in quella determinata area. Per eliminare le copie duplicate e tenerne solo una viene utilizzato un algoritmo chiamato Average Non-Max Suppression (ANMS) che è una variante del Non-Max Suppression tipicamente utilizzato dai modelli di visione artificiale. Invece che tenere la label con lo score maggiore ed eliminare tutte le altre, come box viene calcolato il box che deriva dalla media dei box di tutte labels e lo score viene calcolato come la media dei loro score.
Questo metodo è fondato sul ragionamento che non bisognerebbe buttare via delle informazioni già possedute ma piuttosto riutilizzarle per scoprire qualcosa di nuovo. Per esempio ad uno stesso elemento visualizzato dentro due sezioni differenti di un' immagine potrebbero venirgli assegnati due score diversi. Mentre NMS conserverebbe solo il valore più alto tra i due, ANMS li utilizzerebbe entrambi per ottenere un valore ancora più affidabile aumentando quindi la veridicità della classificazione.
\subsubsection{Creazione di raggruppamenti di labels correlate} 
A questo punto tutti gli elementi sono stati individuati e classificati ma rimane comunque il problema che, a causa della precedente scomposizione, gli oggetti situati all'interno delle aree di sovrapposizione risulterebbero individuati due o più volte. Come si può vedere in figX, questo numero varia in base al numero di regioni sulle quali giace l'oggetto. Il secondo problema è che due elementi vicini \footnote{Due label sono considerate vicine se sono intersecate tra di loro ed intersecano anche almeno una zona di sovrapposizione}, anche se classificati nella stessa categoria, non è detto che necessariamente debbano rappresentare lo stesso elemento. Un esempio di questo caso lo si può notare in figX. Un caso ancora peggiore è quello mostrato in figX dove non solo l'elemento è situato su più regioni differenti ma sussiste anche il problema che ogni parte dell'elemento verrebbe classificata in modo diverso a causa della loro ambiguità. Infine, la figX mostra un oggetto che si distribuisce su molte regioni ed ogni sua label presenta dimensioni diverse.
La soluzione individuata consiste nel raggruppare labels correlate tra loro in insiemi di labels dette raggruppamenti\gls. Due labels sono in correlazione tra di loro se soddisfano una \textbf{condizione di correlazione} sotto riportata.\\
\textbf{Condizione di correlazione}: Per effettuare un corretto raggruppamento delle labels viene anche tenuta in considerazione la categoria a loro associata tramite la classificazione insieme allo score assegnato. Per definire il risultato della condizione è inoltre necessario stabilire una soglia\gls di probabilità per considerare una label come affidabile o meno. Di seguito vengono riportati i vari casi per decidere se la condizione è vera o falsa.
\begin{itemize}
\item \textbf{True}: Le due labels hanno la stessa categoria ed entrambe con score uguale o maggiore della soglia;
\item \textbf{True}: Le due labels hanno la stessa categoria ma almeno una delle due ha score minore della soglia;
\item \textbf{True}: Le due labels hanno categoria diversa ma almeno una delle due ha score minore della soglia;
\item \textbf{False}: Le due labels hanno categoria diversa ed entrambe con score uguale o maggiore della soglia;
\end{itemize}
Prima di cominciare con il raggruppamento, vengono inizialmente individuate tutte le labels che intersecano i confini di regioni causati dalle aree di sovrapposizione o che non distino più di un fissato numero di pixels, detto overlap\gls, da esse.
Ai fini di controllare se una label interseca un' altra entità o meno viene anche tenuta in considerazione una tolleranza\gls che indica quanto il box della label può essere distante da quell'entità affinché questa venga comunque considerata come intersecata.
Per creare i raggruppamenti di labels è stato ideato il seguente algoritmo:
\begin{enumerate}
\item Vengono tenute solo le labels che intersecano almeno un confine di regione e sono inizializzate come \textit{non controllate};
\item Viene selezionata una label qualsiasi \textit{non controllata} e la si imposta come \textit{controllata};
\item Per ogni label \textit{controllata} ma non ancora \textit{Raggruppata} controlla se ci sono altre labels \textit{non controllate} che la intersecano o che siano distanti entro la tolleranza\gls fissata, che rispettino la \textbf{condizione di correlazione} e che non siano entrambe interamente comprese all'interno della stessa regione.
\item Le labels così trovate diventano a loro volta \textit{controllate};
\item Si ripetono i punti 3 e 4 fino a che non sia più possibile trovare ulteriori labels;
\item Tutte le label \textit{controllate} vengono ora classificate come \textit{raggruppate} e viene assegnato un numero progressivo ad ogni label \textit{raggruppata} in modo da identificarne il gruppo di appartenenza;
\item Si ripetono i punti da 2 a 6 fino a che tutte le labels non vengano raggruppate. L'algoritmo in questo modo termina sempre ed è possibile che un raggruppamento comprenda una sola label.
\end{enumerate}
E' da notare che labels intersecanti ma comprese nella stessa regione ed al di fuori delle zone di overlap non sono motivo di interesse in quanto l'algoritmo di Non-Maximum Suppression utilizzato dalla rete in fase di post-processing ci assicura che labels intersecanti individuino elementi diversi.
In seguito bisogna trasformare ogni raggruppamento in una nuova label che racchiuda tutte le labels che lo compongono. Per fare questo vengono esaminate le coordinate di ogni vertice di tutte le labels di un raggruppamento in modo tale da trovare quattro nuovi vertici di un rettangolo che soddisfi i requisiti sopra discussi. Il nuovo box così creato andrà a sostituire le labels del rispettivo raggruppamento e per deciderne la categoria e lo score viene applicata una \textbf{regola di classificazione}: categoria e score assegnati saranno pari alla classificazione posseduta dalla label con score maggiore mentre. \\
A questo punto l'algoritmo può dirsi concluso ed è in grado di riconoscere gli elementi in un'immagine in 4K con un'accuratezza accettabile e buona velocità. Tuttavia in casi particolari come quello mostrato in figura figX l'algoritmo commetterebbe un errore di classificazione in quanto individuerebbe tre elementi diversi con una sola label.
\subsubsection{Raggruppamenti di labels utilizzati come region proposal}
Un ulteriore miglioramento dell'algoritmo viene ottenuto utilizzando le labels ottenute dal procedimento descritto in precedenza come nuove regioni sulle quali applicare nuovamente Faster R-CNN per identificare nuovamente gli elementi contenuti nella regione ma con maggiore precisione in quanto questa volta l'area non verrà affetta da problemi di frammentazione dando quindi la possibilità alla rete di esaminare l'oggetto per intero. La regione viene prima inizializzata rimuovendo la sua label e poi ripopolata dalle nuove labels identificate dalla rete.
Il primo problema che salta fuori è che durante questo procedimento la rete identificherà nuovamente anche quegli elementi che casualmente si trovavano dentro la regione coinvolta ma che erano già stati trovati anche in precedenza. Tuttavia questo problema viene tranquillamente risolto applicando un algoritmo di Average Non-Max Suppression, utilizzato già in precedenza, per eliminare oggetti quasi completamente sovrapposti. Il secondo problema riguarda ancora gli oggetti che stanno a cavallo tra la regione interessata e l'immagine originale, questa volta però, avendoli già individuati nella loro interezza durante la prima fase è quindi solamente necessario integrare la nuova label con quella già trovata in precedenza. 
Un caso particolare lo si ha quando la la regione in esame risulti essere così estesa da vanificare i vantaggi ottenuti dalla frammentazione. Per far fronte a questo problema basta ridimensionare l'area coinvolta fino a portarla ad avere dimensioni gestibili da una rete. In questo caso la perdita di risoluzione e quindi di dettagli non comporterebbe un grave problema in quanto gli elementi visibili solo grazie all'alta definizione sono già stati individuati nella fase precedente. Nel caso in cui dovessero venire nuovamente identificati verrebbero gestiti dall'ANMS per ottenerne una migliore approssimazione. Questa funzionalità permette di migliorare l'accuratezza quando si vogliono identificare oggetti che si estendono su due o più regioni o per migliorare la detection di gruppi di elementi molto vicini tra loro ed in prossimità di un confine. 


