\section{Sviluppo}
\subsection{Sviluppo algoritmo per riconoscimento di elementi in un'immagine frammentata}
Al fine di implementare l'algoritmo è stata creata una libreria contenente numerose funzioni per lavorare con le labels ritornate dal modello come per esempio ottenerne la posizione o controllare le loro intersezioni con altre entità. Una labels è composta da un array formato da quattro numero interi caratterizzanti il vertice in alto a sinistra e quello in basso a destra del bounding box, un intero per rappresentare la categoria dell'elemento ed infine un numero decimale compreso tra 1 e 0 per indicarne lo score.
Viene data la possibilità all'utente di ridefinire la propria \textit{condizione di correlazione}, la \textit{regola di classificazione} e la \textit{condizione di matching} passandole come parametro direttamente nella funzione. Altri parametri passabili includono: le labels, le dimensioni delle regioni e dello stride e la quantità di overlap, sia in verticale che in orizzontale, e di tolleranza in pixels.
Alla fine l'algoritmo ritornerà una lista di tutte le labels presenti nell'immagine.\\ Nella seguente sezione ne viene riportata una sua implementazione.
\subsubsection{Implementazione}
\begin{lstlisting}[language=Python, caption=Python example]
from faster_nms import faster_nms
import numpy as np
import labels as lb

def process_image_labels(boxes, region_size=(300, 300), stride_size=(270, 270), overlap=(0, 0), tol=0, condition=None, find_category=None, matching=None):
    if condition is None:
        condition = lb.condition
    if find_category is None:
        find_category = lb.find_category
        
    w, h = lb.img_dim_from_boxes(boxes)
    regions = lb.generate_regions(w, h, region_size, stride_size)
    boxes = faster_nms(boxes, overlapThresh=0.8)

    # Keeps only the labels intersecting one or more region edges
    lb.get_intersect_edges_labels(boxes, regions, tol, overlap)
    # All labels are set as not-checked and not-grouped
    checked = np.zeros((np.ma.size(ne_boxes, 0)))
    grouped = np.ones((np.ma.size(ne_boxes, 0))) * (-1)
    n_group = 0
    for i in range(len(ne_boxes)):
        # Select a label and sets it as checked
        if not checked[i]:
            checked[i] = True
            while True:
                found = 0
                # If a label is checked then it means it is not-grouped
                for j in range(len(ne_boxes)):
                    if checked[j] and grouped[j] == -1:
                        for k in range(len(ne_boxes)):
                        # check for the conditions to be true
                            if not checked[k] and lb.intersection(ne_boxes[j, :], ne_boxes[k, :], tol) and condition(ne_boxes[j, :], ne_boxes[k, :]) and lb.intersect_common_edge(ne_boxes[j, :], ne_boxes[k, :], regions, tol, overlap) and lb.matched(ne_boxes[j, :], ne_boxes[k, :]) and lb.matched(ne_boxes[j, :], ne_boxes[k, :]) and not lb.belong_same_region_strict_group(ne_boxes[k, :], checked_boxes, regions, tol):
                                # The new label is set as checked
                                checked[k] = True
                                found += 1
                # The cycle is repeated until no new labels can be found
                if found == 0:
                    break
            # All the checked labels are set as grouped and is them assigned a number with the purpose of identify their group ID
            for j in range(len(ne_boxes)):
                if checked[j] and grouped[j] == -1:
                    grouped[j] = n_group
            n_group += 1
    # Now we have that each label only belongs to a single group

    # Now that we have grouped the labels each group is merged into a label containing all of them
    new_boxes = np.zeros((0, 6))
    for i in range(n_group):
        # For each group
        v = np.zeros((0, 6))
        count = 0
        for j in range(len(ne_boxes)):
            if grouped[j] == i:
                v = np.append(v, ne_boxes[j, :])
                count += 1
        v = v.reshape(count, 6)
        # Find the coordinates of the labels containing the whole group
        xx1 = np.amin(v, axis=0)[0]
        yy1 = np.amin(v, axis=0)[1]
        xx2 = np.amax(v, axis=0)[2]
        yy2 = np.amax(v, axis=0)[3]
        # find_category can be redefined by the user
        categories, scores = find_category(v)
        for j in range(len(categories)):
            new_boxes = np.append(new_boxes, np.array([xx1, yy1, xx2, yy2, categories[j], scores[j]]))
    # new_boxes are the labels resulting from grouping algorithm
    new_boxes = new_boxes.reshape(int(len(new_boxes) / 6), 6)

    # The algorithm is over now thus we can return the results
    final_boxes = np.append(new_boxes, old_boxes, 0)

    return final_boxes
\end{lstlisting}
\subsubsection{Test di integrazione}
Al fine di verificarne la correttezza sono stati implementati 80 test di integrazione. Essi hanno il compito di testare l'algoritmo su diverse disposizioni e quantità di labels impostando i parametri con differenti valori in modo tale da riconoscerne il maggior numero di errori possibile. Sono state in tutto testate in totale cinque disposizioni di labels differenti con due diversi valori di overlap, tolleranza, stride e dimensione delle regioni arrivando ad un totale 80 test passati tutti con esito positivo.

