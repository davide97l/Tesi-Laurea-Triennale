\section{Sviluppo}
\subsection{Sviluppo algoritmo per riconoscimento di elementi in un'immagine frammentata}
Al fine di implementare l'algoritmo è stata creata una libreria contenente numerose funzioni per lavorare con le labels ritornate dal modello come per esempio ottenerne la posizione o controllare le loro intersezioni con altre entità. Una labels è composta da un array formato da quattro numero interi caratterizzanti il vertice in alto a sinistra e quello in basso a destra del bounding box, un intero per rappresentare la categoria dell'elemento ed infine un numero decimale compreso tra 1 e 0 per indicarne lo score.
Viene data la possibilità all'utente di ridefinire la propria \textit{condizione di correlazione}, la \textit{regola di classificazione} e la \textit{condizione di matching} passandole come parametro direttamente nella funzione. Altri parametri passabili includono: le labels, le dimensioni delle regioni e dello stride e la quantità di overlap, sia in verticale che in orizzontale, e di tolleranza in pixels.
Alla fine l'algoritmo ritornerà una lista di tutte le labels presenti nell'immagine.\\ Nella seguente sezione ne viene riportata una sua implementazione.
\subsubsection{Implementazione}
\begin{lstlisting}[language=Python, caption=Python example]
from modules.faster_nms import faster_nms
import numpy as np
import modules.labels as lb


def process_image_labels(boxes, region_size=(300, 300), stride_size=(270, 270), overlap=(0, 0), tol=0, threshold_match=50, correlation_condition=None, find_category=None, find_group_label=None):

    # set user defined conditions
    if correlation_condition is None:
        condition = lb.condition
    if find_category is None:
        find_category = lb.find_category
    if find_group_label is None:
        find_group_label = lb.find_group_label
        
    w, h = lb.img_dim_from_boxes(boxes)
    regions = lb.generate_regions(w, h, region_size, stride_size)
    boxes = faster_nms(boxes, overlapThresh=0.8)

    # Keeps only the labels intersecting one or more region edges (ne_boxes = near edges boxes)
    ne_boxes, ne_boxes_indexes = lb.get_intersect_edges_labels(boxes, regions, tol, overlap)
    # All labels are set as not-checked and not-grouped
    checked = np.zeros((np.ma.size(ne_boxes, 0)))
    grouped = np.ones((np.ma.size(ne_boxes, 0))) * (-1)
    # number of label groups
    n_group = 0
    for i in range(len(ne_boxes)):
        checked_boxes = np.zeros((0, 6))
        # Select a label and sets it as checked
        if not checked[i]:
            checked[i] = True
            checked_boxes = np.vstack([checked_boxes, ne_boxes[i]])
            while True:
                found = 0
                # If a label is checked then it means it is also not-grouped
                # For each label checked but not-grouped:
                for j in range(len(ne_boxes)):
                    if checked[j] and grouped[j] == -1:
                        for k in range(len(ne_boxes)):
                             # join conditions
                            if not checked[k] and lb.intersection(ne_boxes[j, :], ne_boxes[k, :], tol) and condition(ne_boxes[j, :], ne_boxes[k, :]) and lb.intersect_common_edge(ne_boxes[j, :], ne_boxes[k, :], regions, tol, overlap) and lb.matched(ne_boxes[j, :], ne_boxes[k, :], threshold_match) and not lb.belong_same_region_strict_group(ne_boxes[k, :], checked_boxes, regions, tol):
                                # The new found label is set as checked
                                checked[k] = True
                                found += 1
                                checked_boxes = np.vstack([checked_boxes, ne_boxes[k]])
                # The cycle is repeated until no new labels can be found
                if found == 0:
                    break
            # All the checked labels are set as grouped and is them assigned a number with the
            # purpose to identify their group ID
            for j in range(len(ne_boxes)):
                if checked[j] and grouped[j] == -1:
                    grouped[j] = n_group
            n_group += 1

    # Now we have that each label only belong to a single group
    # Now that we have grouped the labels each group is merged into a label containing all of them
    new_boxes = np.zeros((0, 6))
    for i in range(n_group):
        # For each group
        v = np.zeros((0, 6))
        count = 0
        for j in range(len(ne_boxes)):
            if grouped[j] == i:
                v = np.vstack((v, ne_boxes[j, :]))
                count += 1
        # Find the coordinates of the labels containing the whole group
        (xx1, yy1), (xx2, yy2) = find_group_label(v)
        # find_category can be redefined by the user, it is based on the category and score of the labels of the group
        categories, scores = find_category(v)
        for j in range(len(categories)):
            new_boxes = np.vstack((new_boxes, np.array([xx1, yy1, xx2, yy2, categories[j], scores[j]])))
    # new_boxes are the labels resulting from grouping algorithm

    # The algorithm is over now thus we can return the results
    ne_boxes_indexes = ne_boxes_indexes.astype(int)
    old_boxes = np.delete(boxes, ne_boxes_indexes, 0)
    final_boxes = np.append(new_boxes, old_boxes, 0)

    return final_boxes
\end{lstlisting}
\subsubsection{Test di integrazione}
Al fine di verificarne la correttezza sono stati implementati 80 test di integrazione. Essi hanno il compito di testare l'algoritmo su diverse disposizioni e quantità di labels impostando i parametri con differenti valori in modo tale da riconoscerne il maggior numero di errori possibile. Sono state in tutto testate in totale cinque disposizioni di labels differenti con due diversi valori di overlap, tolleranza, stride e dimensione delle regioni arrivando ad un totale 80 test passati tutti con esito positivo.

